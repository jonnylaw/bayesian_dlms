---
title: "Seasonal DLM"
---

```{r setup, include=FALSE}
library(tidyverse)
library(coda)
library(ggmcmc)
knitr::opts_chunk$set(cache=TRUE, message=FALSE, warning=FALSE, echo=FALSE)
theme_set(theme_minimal())
```

# Simulate From a Seasonal DLM

A seasonal DLM is given by:

$$\begin{align*}
Y_t | \textbf{x}_t = F \textbf{x}_t + v_t, \quad v_t \sim \mathcal{N}(0, V) \\
X_t | \textbf{x}_{t-1} = G \textbf{x}_t + w_t, \quad w_t \sim \mathcal{N}(0, W) \\
X_y \sim \mathcal{N}(m_0, C_0)
\end{align*}$$

Where the system evolution matrix is block diagonal, containing rotation matrices. If we define $T$ to be the period of the seasonality then the frequency is, $\omega = 2\pi/T$, a rotation matrix for the $h^{\textrm{th}}$ harmonic in the system evolution matrix is given by:

$$R(h, \omega) = \begin{pmatrix}\cos(h\omega) & -\sin(h\omega) \\
\sin(h\omega) & \cos(h\omega) 
\end{pmatrix}$$

Then the system matrix is:

$$G = \begin{pmatrix} 
R(1, \omega) & 0 & \dots & \dots & 0 \\
0 & R(2, \omega) & 0 & \dots & 0\\
\vdots & 0 & \ddots & &\vdots \\
0 & \dots & 0 & R(h, \omega)
\end{pmatrix}.$$

The observation matrix is $1 \times 2h$ dimensional:

$$F = \begin{pmatrix}1 & 0 & 1 & \dots & 1 & 0 \end{pmatrix}.$$

We can specify a seasonal model with trend using:

```tut
import dlm.model._
import cats.implicits._

val mod = Dlm.polynomial(1) |+| Dlm.seasonal(24, 3)
```

Then we can simulate from the model by supplying parameters and use the provided simulate function:

```tut
import breeze.linalg.{DenseMatrix, DenseVector, diag}

val p = Dlm.Parameters(
  v = DenseMatrix((1.0)),
  w = diag(DenseVector(0.01, 0.2, 0.4, 0.5, 0.2, 0.1, 0.4)),
  m0 = DenseVector.fill(7)(0.0),
  c0 = diag(DenseVector.fill(7)(1.0))
)

val sims = Dlm.simulateRegular(0, mod, p).
  steps.
  take(1000).
  toArray
```

```{r simulated-seasonal}
sims = read_csv("../data/seasonal_dlm.csv")

sims %>%
  ggplot(aes(x = time, y = observation)) +
  geom_line() +
  labs(title = "Simulated observations from a seasonal DLM",
       subtitle = "With V = 1.0, W = diag(0.01, 0.2, 0.4, 0.5, 0.2, 0.1, 0.4)")
```

Plot the states:

```{r seasonal-states}
sims %>%
  select(time, contains("state")) %>%
  filter(time > 750) %>%
  gather(key, value, -time) %>%
  ggplot(aes(x = time, y = value)) +
  geom_line() +
  facet_wrap(~key, scales = "free_y", strip.position = "right", ncol = 1) +
  labs(title = "Simulated States of the Seasonal DLM",
       subtitle = "Each dimension of the 7D state plotted against time")
```

# Filtering

We can perform Kalman Filtering, to learn the distribution of the latent state given the data we have simulated:

```tut
val filtered = KalmanFilter.filter(mod, sims.map(_._1), p)
```

```{r filtered-seasonal}
filtered = read_csv("../data/seasonal_filtered.csv")

filtered %>%
  inner_join(sims, by = "time") %>%
  filter(time > 900) %>%
  mutate(upper = qnorm(p = 0.95, mean = state_mean_2, sd = sqrt(state_variance_2))) %>%
  mutate(lower = qnorm(p = 0.05, mean = state_mean_2, sd = sqrt(state_variance_2))) %>%
  gather(key, value, state_mean_2, state2) %>%
  ggplot(aes(x = time, y = value, colour = key)) +
  geom_line() +
  geom_line(aes(x = time, y = lower), linetype = 3, colour = "#000000") +
  geom_line(aes(x = time, y = upper), linetype = 3, colour = "#000000") +
  theme(legend.position = "bottom") +
  labs(title = "Kalman Filtering the Seasonal Model", 
       subtitle = "Mean of the Filtering Distribution overlayed with the actual simulated state with 90% probability intervals")
```

# Smoothing

Kalman Smoothing can be performed:

```tut
val smoothed = Smoothing.backwardsSmoother(mod)(filtered)
```

```{r smoothed-seasonal}
smoothed = read_csv("../data/seasonal_smoothed.csv")

smoothed %>%
  filter(time < 500) %>%
  inner_join(sims, by = "time") %>%
  mutate(upper_smoothed = qnorm(p = 0.975, mean = state_mean_1, sd = sqrt(state_variance_1))) %>%
  mutate(lower_smoothed = qnorm(p = 0.025, mean = state_mean_1, sd = sqrt(state_variance_1))) %>%
  gather(key, value, state1, state_mean_1) %>%
  ggplot(aes(x = time, y = value, colour = key)) +
  geom_line() +
  geom_line(aes(x = time, y = lower_smoothed), linetype = 2, colour = "#000000") +
  geom_line(aes(x = time, y = upper_smoothed), linetype = 2, colour = "#000000") +
  theme(legend.position = "bottom") +
  labs(title = "Smoothed State Estimate",
       subtitle = "Actual state and smoothed state, with associated 95% intervals")
```

## Parameter Learning using Gibbs Sampling

```{r parameter_values, echo=FALSE}
actual_values = tibble(
  Parameter = c("V", paste0("W", 1:7)),
  actual_value = c(1.0, 0.01, 0.2, 0.4, 0.5, 0.2, 0.1, 0.4)
)
```

The system matrix $W$ is diagonal, hence the Inverse Gamma distribution can be used for the observation and system noise matrices in a Gibbs Sampler. The state is sampled using Forward Filtering Backward Sampling (FFBS), then conditional on the state, the system and observation noise matrices are sampled from Inverse Gamma distributions. 

```tut
val iters = GibbsSampling.sample(
    mod, 
    InverseGamma(5.0, 4.0), 
    InverseGamma(17.0, 4.0), 
    p, 
    sims.map(_._1))
```

The diagnostic plots are below:

```{r seasonal-v-diagnostics, echo=FALSE, fig.cap="Traceplot and running mean for posterior distribution of the observation variance parameter, $V$"}
iters = read_csv("../data/seasonal_dlm_gibbs.csv")

params = mcmc(iters) %>%
  ggs() %>%
  inner_join(actual_values, by = "Parameter")

p1 = params %>%
  filter(Parameter == "V") %>%
  ggplot(aes(x = Iteration, y = value)) +
  geom_line() +
  geom_hline(aes(yintercept = actual_value), colour = "#ff0000")

p2 = params %>%
  filter(Parameter == "V") %>%
  mutate(running_mean = dlm::ergMean(value)) %>%
  ggplot(aes(x = Iteration, y = running_mean)) +
  geom_line() +
  geom_hline(aes(yintercept = actual_value), colour = "#ff0000")

# p3 = ggs_autocorrelation(params %>% filter(Parameter == "V"))

gridExtra::grid.arrange(p1, p2, ncol = 1)
```

```{r seasonal-w-diagnostics, echo=FALSE, fig.cap="Diagnostic plots for the MCMC chain representing draws from the posterior distribution of the System noise covariance matrix for the simulated seasonal model"}
p1 = params %>%
  filter(Parameter %in% paste0("W", 1:7)) %>%
  ggplot(aes(x = Iteration, y = value)) +
  geom_line() +
  # geom_hline(aes(yintercept = actual_value), colour = "#ff0000") +
  facet_wrap(~Parameter, strip.position = "right")

p2 = params %>%
  group_by(Parameter) %>%
  filter(Parameter %in% paste0("W", 1:7)) %>%
  mutate(running_mean = dlm::ergMean(value)) %>%
  ggplot(aes(x = Iteration, y = running_mean)) +
  geom_line() +
  # geom_hline(aes(yintercept = actual_value), colour = "#ff0000") +
  facet_wrap(~Parameter, scales = "free_y", strip.position = "right")

gridExtra::grid.arrange(p1, p2, ncol = 1)
```

# Forecast DLM

Forecasting a DLM is equivalent to running the Kalman Filter without any observations at the time of interest. We initialise the forecast by using the posterior distribution of the latent state at the time of the last observation, $x_T \sim \mathcal{N}(m_T, C_T)$ and use the values of the parameters identified using Gibbs sampling.

First we take the mean value of the MCMC parameters, assuming that the parameters have been written to a CSV called `seasonal_dlm_gibbs.csv` with eight columns, $V, W_1,\dots,W_7$:

```tut
import java.nio.file.Paths
import kantan.csv._
import kantan.csv.ops._
import breeze.stats.mean

val mcmcChain = Paths.get("data/seasonal_dlm_gibbs.csv")
val read = mcmcChain.asCsvReader[List[Double]](rfc.withHeader)

val params: List[Double] = read.
  collect { case Success(a) => a }.
  toList.
  transpose.
  map(a => mean(a))

val meanParameters = Dlm.Parameters(
  DenseMatrix(params.head), 
  diag(DenseVector(params.tail.toArray)), 
  p.m0,
  p.c0)
```

When then use these parameters to get the posterior distribution of the final state:

```tut
  val filtered = KalmanFilter.filter(mod, sims.map(_._1), meanParameters)
  val (mt, ct, initTime) = filtered.map(a => (a.mt, a.ct, a.time)).last
```

We then initialise the forecast function with state state posterior at the time of the last observation:

```tut
  val forecasted = Dlm.forecast(mod, mt, ct, initTime, meanParameters).
    take(100).
    toList
```

The results of the forecasting and 95% prediction intervals are below:

```{r forecast_seasonal_dlm, echo=FALSE, message=FALSE, warning=FALSE}
forecast = read_csv("../data/seasonal_model_forecast.csv")

forecast %>%
  rename(time = Time, forecast = Observation) %>%
  mutate(upper = qnorm(p = 0.95, mean = forecast, sd = sqrt(Variance)),
         lower = qnorm(p = 0.05, mean = forecast, sd = sqrt(Variance))) %>%
  bind_rows(sims) %>%
  filter(time > 900) %>%
  gather(key, value, forecast, observation) %>%
  ggplot() +
  geom_line(aes(x = time, y = value, colour = key)) +
  geom_line(aes(x = time, y = lower), linetype = 2) +
  geom_line(aes(x = time, y = upper), linetype = 2) +
  labs(title = "Forecast for 100 Time Points") +
  theme(legend.position = "bottom")
```