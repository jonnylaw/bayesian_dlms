---
title: "Correlated Environmental Sensor Data"
author: "Jonathan Law"
date: "28 September 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dlm)
library(magrittr)

theme_set(theme_minimal())
```

# Urban Observatory Environment Data

```{r make-request, eval=FALSE}
# This should not be used to query long intervals
start_date = "20170901"
end_date = "20170907"
api_key = "t5dhdds7hiyv1qc0v91g9v1hvq7kftb6vgueemtibx15iic9maiv9ha5003sbvx805v9ppd36t7damx37r7q1otjpw"
query = paste0("http://uoweb1.ncl.ac.uk/api/v1/sensor/data/raw.csv?", 
               "sensor_name=new_new_emote_1114",
               "&start_time=", start_date,
               "&end_time=", end_date,
               "&variable=Humidity-and-Temperature",
               "&api_key=", api_key)

r = httr::GET(query)
(data = read_csv(httr::content(r, "text")))
```

```{r import_data}
data = read_csv("../data/new_new_emote_1114.csv")
```

```{r}
library(magrittr)
data %<>%
  filter(Variable %in% c("Humidity", "Temperature"))
```

```{r plot_timeseries}
stats = data %>%
  group_by(Variable) %>%
  summarise(mean = mean(Value), sd = sd(Value))

data %>%
  filter(Timestamp > "2017-09-01") %>%
  inner_join(stats) %>%
  rowwise() %>%
  mutate(norm_value = (Value - mean) / sd) %>%
  ggplot(aes(x = Timestamp, y = norm_value, colour = Variable)) +
  geom_line() +
  labs(title = "Humidity and Temperature Recordings", 
       subtitle = "Normalised Humidity and Temperature recorded at sensor new_new_emote_1114")
```

```{r Bivariate-Distribution}
data %>%
  filter(Timestamp > "2017-09-01") %>%
  distinct() %>%
  select(Timestamp, Variable, Value) %>%
  spread(key = Variable, value = Value) %>%
  ggplot(aes(x = Temperature, y = Humidity)) +
  geom_point()
```

```{r histograms}
data %>% 
  inner_join(stats) %>%
  mutate(norm_value = (Value - mean) / sd) %>%
  filter(Timestamp > "2017-09-01") %>%
  ggplot(aes(x = norm_value)) +
  geom_histogram(bins = 100) +
  facet_wrap(~Variable, ncol = 1) +
  labs(title = "Histograms of normalised values")
```

In order to apply a DLM model to this data, it needs to be observed on a regular grid.

```{r}
humid_temp = data[-c(96405, 589192),] %>%
  select(Timestamp, Value, Variable) %>%
  spread(key = Variable, value = Value)
```

The data is observed once per minute. In order to fit the DLM models we must ensure any missing data has an associated timestamp. To do this, left join onto a contiguous sequence of times:

```{r}
start_time = lubridate::round_date(min(humid_temp$Timestamp), "hour")
end_time = start_time + lubridate::dweeks(8)
dates = seq(from = start_time, to = end_time, by = "1 hour")

humid_temp = tibble(Hour = dates) %>%
  left_join(humid_temp %>% mutate(Hour = lubridate::round_date(Timestamp, "hour")), by = "Hour") %>%
  group_by(Hour) %>%
  summarise_at(c("Humidity", "Temperature"), function(x) mean(x, na.rm = T))
```

```{r}
humid_temp %>%
  gather(key, value, -Hour) %>%
  ggplot(aes(x = Hour, y = value)) +
  geom_line() +
  facet_wrap(~key, ncol = 1, scales = "free_y")
```


```{r, eval=FALSE}
humid_temp %>%
  mutate(relative_time = as.integer(difftime(Hour, start_time, units = "hour"))) %>%
  select(relative_time, Humidity, Temperature) %>% 
  write_csv(., path = "../data/humidity_temperature_1114.csv")
```

# Joint DLM

First order joint DLM for humidity and temperature:

```{r gibbs-first-order-joint}
iters = read_csv("../data/")
```


# A Regression DLM

Regress the values of Humidity against Temperature using a regression DLM:

$$\begin{align*}
Y_t &= F_t x_t + v_t, \qquad v \sim \mathcal{N}(0, V), \\
x_t &= x_{t-1} + w_t, \qquad w \sim \textrm{MVN}(0, W),
x_0 \sim \textrm{MVN}(m_0, C_0).
\end{align*}$$

$Y_t$ is a univariate observation of the temperature at time $t$, $F_t$ contains the humidity at time $t$ and the regression intercept term:

$$F_t = \begin{pmatrix} 1 & h_t\end{pmatrix}.$$

$x_t$ is the latent state and can be thought of as the time varying regression coefficients.

# A Gaussian Joint-DLM

In order to forecast processes which are highly correlated, we can model the correlation between the series exploiting the information from both time series to give a more accurate forecast. We first specify a model for the Temperature and humidity seperately and then combine the two DLMs using an outer sum. 

## Temperature Model

The temperature model is a composition of a linear trend model and a daily seasonal model. The Observation and system evolution matrices are give as follows:

$$
\begin{align*}
F_t &= \begin{pmatrix} 1 \\ 1 \\0 \\1 \\0 \\ \vdots \\ 0 \end{pmatrix}, \\
G_t &= \begin{pmatrix} 
  1 & 0 & \dots & \dots & \dots &\dots & 0 \\ 
  0 & \cos(\omega) & -\sin(\omega) & 0 & \dots &\dots & 0 \\
  0 & \sin(\omega) & \cos(\omega) & 0 & \dots &\dots & 0 \\
  0 & 0 & 0 & \ddots & \ddots & \dots & 0 \\
  \vdots & \dots & \dots & \dots & \dots & \cos(h\omega) & -\sin(h\omega) \\
  0 & \dots & \dots & \dots & \dots & \sin(h\omega) & \cos(h\omega)
\end{pmatrix}
\end{align*}
$$

Where here $\omega = 2 \Pi / T$, where $T$ is the period of the of the seasonality. In this case $T = 60 * 24$ Since the observations are recorded every minute. $h$ represents the number of harmonics in the seasonal model.

### Fitting the temperature model

* Plot temperature data

```{r}
humid_temp %>%
  ggplot(aes(x = Hour, y = Temperature)) +
  geom_line()
```

* Simulate the data, this looks like a fairly reasonable model

```{r}
sims = read_csv("../data/simulated_temperature_data.csv")

sims %>%
  gather(key, value, -time) %>%
  ggplot(aes(x = time, y = value)) +
  geom_line() +
  facet_wrap(~key, ncol = 1)
```

* plot simulated data 

* Kalman Filter Temperature Data

```{r}
filtered = read_csv("../data/temperature_filtered.csv")

humid_temp %>%
  mutate(time = as.integer(difftime(Hour, start_time, units = "hour"))) %>%
  select(time, Temperature) %>%
  inner_join(filtered, by = "time") %>%
  select(-contains("state")) %>%
  mutate(upper = qnorm(p = 0.975, mean = one_step_forecast, sd = sqrt(one_step_variance))) %>%
  mutate(lower = qnorm(p = 0.025, mean = one_step_forecast, sd = sqrt(one_step_variance))) %>%
  gather(key, value, -time, -one_step_variance, -lower, -upper) %>%
  ggplot(aes(x = time, y = value, colour = key)) +
  geom_line() +
  geom_line(aes(x = time, y = lower), linetype = 2, colour = "#999999") +
  geom_line(aes(x = time, y = upper), linetype = 2, colour = "#999999")
```

* Fit the model using optim

```{r}
model = function(theta) {
  dlmModPoly(1, dV = exp(theta[1]), dW = exp(theta[2])) + dlmModTrig(s = 24, q = 3, dW = exp(theta[3:8]))
}
fit = dlmMLE(y = humid_temp[1:150,] %$% Temperature, parm = rep(1, 8), build = model)
exp(fit$par)
```

```{r}
plot(humid_temp[1:150,] %$% Temperature, type = "l")
```


```{r read-chain}
temp_iters = read_csv("../data/temperature_model_parameters.csv")
```

```{r autocorrelation}
library(coda)
library(ggmcmc)

chain = mcmc(temp_iters) %>%
  ggmcmc::ggs()

ggmcmc(chain)
```

```{r traceplot}
ggs_traceplot(chain)
```

```{r ergmean}
ggs_running(chain)
```




# A Non-Gaussian Joint-Model

* Humidity is between 0 and 100, scaled Beta?
* Use Particle Filter for Beta Observation

# A Continuous Time Non-Gaussian Joint Model

* Use SDEs for state space